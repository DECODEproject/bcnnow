# Code generated by protoc-gen-twirp_python v5.5.0, DO NOT EDIT.
# source: datastore.proto

try:
    import httplib
    from urllib2 import Request, HTTPError, urlopen
except ImportError:
    import http.client as httplib
    from urllib.request import Request, urlopen
    from urllib.error import HTTPError
import json
from google.protobuf import symbol_database as _symbol_database
import sys

_sym_db = _symbol_database.Default()

class TwirpException(httplib.HTTPException):
    def __init__(self, code, message, meta):
        self.code = code
        self.message = message
        self.meta = meta
        super(TwirpException, self).__init__(message)

    @classmethod
    def from_http_err(cls, err):
        try:
            jsonerr = json.load(err)
            code = jsonerr["code"]
            msg = jsonerr["msg"]
            meta = jsonerr.get("meta")
            if meta is None:
                meta = {}
        except:
            code = "internal"
            msg = "Error from intermediary with HTTP status code {} {}".format(
                err.code, httplib.responses[err.code],
            )
            meta = {}
        return cls(code, msg, meta)

class DatastoreClient(object):
    """
    Datastore is the interface we propose exposing to implement an encrypted
    datastore for the IOT scale model and pilot for DECODE. We expose two API
    methods, one to write and one to read data.
    """

    def __init__(self, server_address):
        """Creates a new client for the Datastore service.

        Args:
            server_address: The address of the server to send requests to, in
                the full protocol://host:port form.
        """
        if sys.version_info[0] > 2:
            self.__target = server_address
        else:
            self.__target = server_address.encode('ascii')
        self.__service_name = "decode.iot.datastore.Datastore"

    def __make_request(self, body, full_method):
        req = Request(
            url=self.__target + "/twirp" + full_method,
            data=body,
            headers={"Content-Type": "application/protobuf"},
        )
        try:
            resp = urlopen(req)
        except HTTPError as err:
            raise TwirpException.from_http_err(err)

        return resp.read()

    def write_data(self, write_request):
        """
        WriteData is our function call that writes a single encrypted data event to
        the underlying storage substrate. It takes a WriteRequest containing the
        actual data to be stored along with public key of the bucket for which data
        should be persisted and the submitting user's DECODE user id. THese
        additional attributes allow us to request the data from the bucket by
        public key.
        """

        serialize = _sym_db.GetSymbol("decode.iot.datastore.WriteRequest").SerializeToString
        deserialize = _sym_db.GetSymbol("decode.iot.datastore.WriteResponse").FromString

        full_method = "/{}/{}".format(self.__service_name, "WriteData")
        body = serialize(write_request)
        resp_str = self.__make_request(body=body, full_method=full_method)
        return deserialize(resp_str)

    def read_data(self, read_request):
        """
        ReadData is used to request data from the data store. Data is requested
        keyed by the public key used to encrypt it (encoded as a Base64 or hex
        string probably). In addition a read request allows the client to specify a
        time interval so that data is only retrieved if it was recorded within the
        interval. Pagination is supported to allow for large intervals to be
        requested without having to return all the data in one hit.
        """

        serialize = _sym_db.GetSymbol("decode.iot.datastore.ReadRequest").SerializeToString
        deserialize = _sym_db.GetSymbol("decode.iot.datastore.ReadResponse").FromString

        full_method = "/{}/{}".format(self.__service_name, "ReadData")
        body = serialize(read_request)
        resp_str = self.__make_request(body=body, full_method=full_method)
        return deserialize(resp_str)

